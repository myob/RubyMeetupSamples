#This code builds a hashtable of 'pattern_length' characters where each pattern is associated with all the letters
#that follow it in the original text.  The text is then regenerated by starting with a pattern and randomly
#selecting one of the characters that followed the pattern in the original text.  The pattern is then 'shifted' ahead
#by one character and the process repeats until the desired output size is reached.
#The end result is a new text that is statistically highly similar in character pattern to the original, but not at
#all like the original in semantic content.  Style tends to 'leadk through' at pattern sizes around 3 to 5,
#depending on the original text's complexity.  It works better for longer input texts as there is more variability
#to work with.  Shorter input texts result in much less interesting output and can easily get stuck in 'loops' of
#repeating text.  Grab an article off the web or a set of song lyrics and give it a try.
#This shows off string processing and hast table use, random numbers, and a way to grab the entire contents of a file.
#Note that the file needs to be plain text, not rtf, doc, pdf, or other format that embeds non-text information.
#Enjoy!

class MarkovGenerator
  attr_accessor :dict; :in_text; :pattern_length; :out_text; :end_point
  #set up all our instance variables as read-write up front
end

def initialize()
  #lazy programmer crams all the setup and then the processing steps here to simplify use
  #refactor this to better form, allow dynamic specification of input file, pattern length, and output size
  #as an exercise ;-)
  @dict=Hash.new{ |hash, key| hash[key] = Array.new }
  #defining the hash using this form means whenever a key is not found, a new empty array is associated
  #with the key.  If we had done Hash.new(Array new), we would get only one array, the one created when
  #the hash was defined.
  @out_text=''
  #@pattern_length= 3
  @pattern_length= 4
  #@pattern_length= 5
  #These are the 3 most useful, uncomment the one you want to use...  Lazy programmer strikes again
  prep_text
  build_dictionary
  build_output
  #run the 3 methods that do set up and provide output; lazy programmer again...
end

def prep_text()
  #I always 'prep' the text by making sure that all white space is reduced/converted to a single space character
  @in_text = File.read('tale_of_two_cities_excerpt.txt')
  @in_text=@in_text.gsub!(%r{\s+}, ' ')  #destructively modify the incoming text
  @end_point=@in_text.size #remember the original size of the input
  @in_text=@in_text<<@in_text[0,(@pattern_length + 1)]
  #wrap the beginning onto the end so we can get the final pattern pointing back to the beginning instead of
  #falling off the end of the input string
end

def build_dictionary()
  #walk through the ext from position to position, grabbing pattern_length chars for the key and the next char
  #to add to the values
  (0..@end_point).each do |pos|
    @dict[@in_text[pos, @pattern_length].intern]<< @in_text[(pos + @pattern_length)]
    #intern 'freezes' the string so the original occurrence will be used any time that spelling shows up
    #hash tables work best with symbols or frozen strings for keys so all lookups are unambiguous
  end
end

def build_output()
  start_point = rand(@end_point)  #pick a random number for a starting point
  @out_text<<@in_text[start_point,@pattern_length + 1]  #use the random start point to grab the initial text
  char_list=@dict[@out_text.intern]  #find the collection of following characters
  selected_char=char_list[rand(char_list.size)]  #pick one
  (1...5000).each do |pos|  #get 5000 characters of output, change end point to suit
    new_pattern=@out_text[pos,@pattern_length]
    char_list=@dict[new_pattern.intern]
    selected_char=char_list[rand(char_list.size)]  #-1)]
    @out_text<<selected_char  #appends the selected character to the string.  Could have used +
  end
  puts @out_text  #show the result
end

MarkovGenerator.new
